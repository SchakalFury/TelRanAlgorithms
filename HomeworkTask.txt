а. Приведите пример использования амортизированного анализа в практике.

Одним из примеров использования амортизированного анализа является динамический массив (ArrayList) в Java. 
Операция добавления элемента в ArrayList может занять O(n) времени, если не хватает места для нового 
элемента, потому что необходимо создать новый массив большего размера и скопировать все элементы из 
старого массива в новый. Однако, мы можем использовать амортизированный анализ, чтобы показать, что среднее 
время на операцию добавления элемента составляет O(1).

Концепция амортизированного анализа заключается в том, что мы анализируем последовательность операций, 
а не отдельные операции. В случае ArrayList, мы можем использовать стратегию удвоения размера массива при 
каждой операции добавления, чтобы убедиться, что количество копирований массива не увеличивается слишком 
быстро. Когда массив заполнен, мы выделяем новый массив двойного размера и копируем все элементы из старого 
массива в новый. Операция добавления элемента в новый массив занимает O(1) времени. Поскольку мы удваиваем 
размер массива при каждой операции добавления, количество копирований массива ограничено O(log n) раз. 
Следовательно, среднее время на операцию добавления элемента равно O(1).

import java.util.ArrayList;

public class AmortizedAnalysisExample {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        
        // добавляем элементы в список
        for (int i = 1; i <= 10; i++) {
            list.add(i);
            System.out.println("Добавлен элемент " + i);
        }
    }
}

В этом примере мы создаем новый ArrayList и добавляем в него 10 элементов с помощью метода add(). 
При каждой операции добавления ArrayList автоматически удваивает размер массива, если текущий 
массив заполнен. Это гарантирует, что количество копирований массива не увеличивается 
слишком быстро и среднее время на операцию добавления элемента равно O(1).

b. Рассмотрите задачу динамического увеличения массива. 
Реализуйте функцию, которая принимает на вход массив 
и число элементов, и возвращает новый массив, 
который содержит все элементы исходного массива и заданное число новых элементов.

public static int[] expandArray(int[] arr, int newElements) {
    int[] newArr = new int[arr.length + newElements]; // создаем новый массив с увеличенным размером
    System.arraycopy(arr, 0, newArr, 0, arr.length); // копируем все элементы из исходного массива в новый
    return newArr;
}


3.Составьте блок схему для алгоритма горизонтальной масштабируемости инфраструктуры, в которую входит БД и серверные мощности.

                      +-----------------------------+
                      |       База данных           |
                      |                             |
                      +-----------------------------+
                              |   |
+----------------------------------------------------------------------+
|          Нагрузочный балансировщик                                   |
|     (использует алгоритм балансировки)                               |
+----------------------------------------------------------------------+
      |   |                                               |   |
+-----------------------------------+        +-----------------------------------+
|         Сервер 1                  |        |         Сервер 2                  |
|  (запущен на виртуальной машине)  |        |   (запущен на виртуальной машине) |  
+-----------------------------------+        +-----------------------------------+
      |   |                                               |   |
+-----------------------------------+        +-----------------------------------+
|          Docker                   |        |           Docker                  |
|  (использует контейнеризацию)     |        |    (использует контейнеризацию)   |
+-----------------------------------+        +-----------------------------------+
      |   |                                               |   |
+-----------------------------------+        +-----------------------------------+
|         ОС 1                      |        |            ОС 2                   |
| (обеспечивает работу сервера)     |        |    (обеспечивает работу сервера)  |
+-----------------------------------+        +-----------------------------------+	



Объяснение блок-схемы:

- База данных хранит все данные, которые используются в приложении.

- Нагрузочный балансировщик распределяет трафик между несколькими серверами, 
чтобы поддерживать равномерную нагрузку и избежать перегрузки любого конкретного сервера. 
Он использует алгоритм балансировки для определения, какой сервер должен обрабатывать каждый запрос.

-Серверы запущены на виртуальных машинах. Каждый сервер находится в своей виртуальной машине, 
что обеспечивает изоляцию и надежность приложения. Виртуальные машины могут быть развернуты на одном 
физическом сервере или на нескольких серверах для повышения отказоустойчивости.
Каждый сервер работает в контейнере Docker, который обеспечивает изоляцию процессов и ресурсов на сервере. 
Docker также упрощает управление конфигурацией и развертыванием приложения.

-На каждом сервере установлена операционная система, которая обеспечивает работу сервера. 
ОС настраивается для максимальной производительности и надежности приложения.	