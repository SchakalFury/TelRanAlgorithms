
Получить от пользователя 3 целочисленные переменные num1, num2 и num3.
Возьмите три добавляемых числа в качестве входных данных для переменных num1, num2 и num3 соответственно.
Объявите целочисленную переменную sum для хранения результирующей суммы трех чисел.
Добавьте 3 числа и сохраните результат в переменной sum.
Вывести значение переменной sum
:канцелярская_кнопка: Задача будет считаться выполненной если:
Написан псевдокод, диаграмма или написан код на JAVA or JavaScript
Алгоритм соответствует характеристикам алгоритма и выдает верный результат



import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // create scanner object to get user input
        Scanner scanner = new Scanner(System.in);
        
        // prompt user to enter the first number
        System.out.print("Enter the first number: ");
        int num1 = scanner.nextInt();
        
        // prompt user to enter the second number
        System.out.print("Enter the second number: ");
        int num2 = scanner.nextInt();
        
        // prompt user to enter the third number
        System.out.print("Enter the third number: ");
        int num3 = scanner.nextInt();
        
        // add the three numbers together and store the result in a variable
        int sum = num1 + num2 + num3;
        
        // display the result
        System.out.println("The sum of the three numbers is: " + sum);
    }
}

=====================================================================================================================================================================

Найти индекс заданного числа в массиве: {3, 6, 4, 7, 2, 1, 9}
Алгоритм на вход должен получать любой массив и одну цифру, индекс которой требуется найти.
Задание считается выполненным если: использован ”Линейный подход” и алгоритм соответствует характеристикам алгоритма и выдает верный результат.

public class Main {
    public static void main(String[] args) {
        int[] arr = {3, 6, 4, 7, 2, 1, 9};
        int num = 7; // the number we want to find
        
        int index = linearSearch(arr, num);
        
        if (index == -1) {
            System.out.println("The number " + num + " is not found in the array.");
        } else {
            System.out.println("The index of the number " + num + " is: " + index);
        }
    }
    
    // linear search algorithm to find the index of a given number in an array
    public static int linearSearch(int[] arr, int num) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == num) {
                return i;
            }
        }
        
        return -1; // return -1 if the number is not found in the array
    }
}

Реализовать алгоритм, который будет находить сумму квадратов всех элементов массива!  {3, 6, 4, 7, 2, 1, 9}
Задание считается выполненным если: использован ”Линейный подход” и алгоритм соответствует характеристикам алгоритма и выдает верный результат.

public class Main {
    public static void main(String[] args) {
        int[] arr = {3, 6, 4, 7, 2, 1, 9};
        int sumOfSquares = linearSumOfSquares(arr);
        System.out.println("The sum of squares of all array elements is: " + sumOfSquares);
    }
    
    // linear approach to find the sum of squares of all elements in an array
    public static int linearSumOfSquares(int[] arr) {
        int sum = 0;
        
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i] * arr[i];
        }
        
        return sum;
    }
}

=====================================================================================================================================================================

Какова временная сложность?
void test1(int n)
{
   if (n==1)
      return;
   for (int i=1; i<=n; i++)
       for (int j=1; j<=n; j++)
           System.out.println("*");
           break;
}

Ответ::

Временная сложность данного кода равна O(n^2), что является квадратичным.

Внешний цикл выполняется n раз, и для каждой итерации внешнего цикла внутренний цикл также выполняется n раз. 
Таким образом, общее количество выполнений внутреннего цикла равно n * n = n^2.
Внутри внутреннего цикла есть единственная строка кода, которая печатает звездочку и имеет постоянную временную сложность O(1).
Таким образом, общая временная сложность кода составляет O(n^2) * O(1) = O(n^2). Это означает, что время, затрачиваемое на код, 
увеличивается квадратично с размером входных данных n.

void test2(int n)
{
   int a = 0;
for (i = 0; i < n; i++)
   for (j = n; j > i; j--)
       a = a + i + j;   
}

Ответ::

Временная сложность данного кода равна O(n^2), что является квадратичным.
Внешний цикл выполняется n раз, и для каждой итерации внешнего цикла внутренний цикл выполняется n - i раз.
Таким образом, общее количество выполнений внутреннего цикла равно:
(n - 1) + (n - 2) + ... + 2 + 1 = n * (n - 1) / 2
Внутри внутреннего цикла есть постоянное количество операций, выполнение которых занимает O(1): добавление i и j к переменной a.
Таким образом, общая временная сложность кода составляет O(n^2) * O(1) = O(n^2). Это означает, что время, затрачиваемое на код, увеличивается квадратично с размером входных данных n.


void test3(int n)
     int i, j, a = 0;
for (i        i <=n; i   
   for (j = 2; j <=n; j   2)
       a=a+n/2;   
}


Ответ::

Временная сложность данного кода равна O(n), что является линейным.

Внешний цикл выполняется n раз, а для каждой итерации внешнего цикла внутренний цикл выполняется n/2 раза (с округлением в меньшую сторону до ближайшего целого числа). Таким образом, общее количество выполнений внутреннего цикла равно:

n/2 + n/2 + ... (n/2 раза) = n/2 * (n/2) = n^2/4

Внутри внутреннего цикла есть постоянное количество операций, выполнение которых занимает O(1): добавление n/2 к переменной a.

Таким образом, общая временная сложность кода составляет O(n^2/4) * O(1) = O(n), что означает, что время, затрачиваемое кодом, линейно увеличивается с размером входных данных n.

=====================================================================================================================================================================

Дано натуральное число N. Выведите слово YES, если число N является точной степенью двойки, или слово NO в противном случае.
Операцией возведения в степень пользоваться нельзя!

public static void main(String[] args) {
    int n = 64; // change this to test different values of n
    boolean isPowerOfTwo = true;
    while (n > 1) {
        if (n % 2 != 0) {
            isPowerOfTwo = false;
            break;
        }
        n = n / 2;
    }
    if (isPowerOfTwo) {
        System.out.println("YES");
    } else {
        System.out.println("NO");
    }
}

Алгоритм использует цикл while для 
многократного деления входного числа 
n на 2, пока оно не станет 1 или 
не встретится нечетное число. Если 
встречается нечетное число, это означает, 
что n не может быть степенью двойки, 
поэтому цикл завершается, а выход 
устанавливается в «НЕТ». Если n становится
равным 1, это означает, что все деления
были успешными, а n является степенью 
двойки, поэтому на выходе устанавливается
значение «ДА».


Дано натуральное число N. Вычислите сумму его цифр.
При решении этой задачи нельзя использовать строки, списки, массивы (ну и циклы, разумеется).

public static void main(String[] args) {
    int n = 12345; // change this to test different values of n
    int sum = 0;
    while (n > 0) {
        sum = sum + n % 10;
        n = n / 10;
    }
    System.out.println(sum);
}

Алгоритм многократно извлекает последнюю
цифру входного числа n с помощью оператора 
по модулю % и добавляет ее к промежуточной 
общей сумме. Затем он делит n на 10, 
чтобы удалить последнюю цифру. Этот процесс 
повторяется до тех пор, пока n не станет 
равным 0, после чего сумма цифр вычисляется 
и выводится на консоль.


Напишите рекурсивный метод, который выводит на экран числа Фибоначчи до N-ого элемента.

public static void main(String[] args) {
    int n = 10; // change this to test different values of n
    for (int i = 1; i <= n; i++) {
        System.out.print(fibonacci(i) + " ");
    }
}

public static int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n-1) + fibonacci(n-2);
    }
}

Метод fibonacci() принимает целочисленный 
аргумент n и возвращает n-е число Фибоначчи, 
используя рекурсию. В базовом случае n равно 
0 или 1, и в этом случае метод просто возвращает n. 
В противном случае метод рекурсивно вычисляет 
n-1-е и n-2-е числа Фибоначчи и складывает их 
вместе для получения n-го числа Фибоначчи.

Метод main() вызывает fibonacci() для каждого 
целого числа от 1 до n и выводит полученные 
числа Фибоначчи на консоль.


Напишите рекурсивный метод, который проверяет, является ли строка палиндромом.

public static void main(String[] args) {
    String s = "racecar"; // change this to test different strings
    if (isPalindrome(s)) {
        System.out.println(s + " is a palindrome");
    } else {
        System.out.println(s + " is not a palindrome");
    }
}

public static boolean isPalindrome(String s) {
    if (s.length() <= 1) {
        return true;
    } else {
        char first = s.charAt(0);
        char last = s.charAt(s.length()-1);
        if (first != last) {
            return false;
        } else {
            String middle = s.substring(1, s.length()-1);
            return isPalindrome(middle);
        }
    }
}

Метод isPalindrome() принимает строковый аргумент 
s и возвращает true, если s является палиндромом, 
и false в противном случае. В базовом случае s 
имеет длину 0 или 1, и в этом случае это всегда палиндром. 
В противном случае метод сравнивает первый и последний 
символы s. Если они не совпадают, то s не является 
палиндромом и метод возвращает false. В противном 
случае метод рекурсивно проверяет, является ли 
подстрока между первым и последним символом палиндромом, 
используя тот же метод isPalindrome().

Метод main() вызывает isPalindrome() для входной 
строки s и выводит сообщение, указывающее, является 
ли s палиндромом или нет.

